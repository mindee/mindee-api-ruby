require 'mindee'

# Init a new client
mindee_client = Mindee::Client.new(api_key: 'my-api-key')

# Load a file from disk
input_source = mindee_client.doc_from_path('/path/to/the/file.ext')

# Put the document class in a local variable to keep the code DRY
doc_class = Mindee::Product::InvoiceSplitter::InvoiceSplitterV1

# Limit the amount of API calls to retrieve your document
MAX_RETRIES = 10

# How many seconds to wait in-between tries
INTERVAL_SECS = 6

# Counter to keep track of how many times we try to retrieve the document
times_tried = 1


queue_result = mindee_client.enqueue(
  input_source,
  doc_class
)

# Get the id of the queue (job)
queue_id = queue_result.job.id

# Recursive function that tries to retrieve the completed document.
# If the document is not "complete", try again
def get_doc_from_async_queue(
    queue_id,
    mindee_client,
    doc_class,
    times_tried=0,
    interval_secs=INTERVAL_SECS,
    max_retries=MAX_RETRIES
  )
    # Have we exceeded our retry count?
    if times_tried >= max_retries
      raise "Maximum retries reached #{times_tried}"
    end

    # Wait for a few seconds before fetching
    sleep interval_secs

    # Fetch and parse the result, using the same type
    parsed_result = mindee_client.parse_queued(doc_class, queue_id)

    # Check whether the result is ready
    if parsed_result.job.status == Mindee::JobStatus::COMPLETED
        # Print a brief summary of the parsed data
        puts parsed_result.document
        return
    # Otherwise, try again...
    else
      get_doc_from_async_queue(
        queue_id, mindee_client,
        doc_class,
        times_tried+1
      )
    end
end

# Start the recursion...
get_doc_from_async_queue(queue_id, mindee_client, doc_class)